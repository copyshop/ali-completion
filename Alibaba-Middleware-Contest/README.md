# Alibaba-Middleware-Contest
首先感谢大神队友carry！ 此次比赛受益匪浅。此版本为最后提交代码的重构版本。

### 题目
天猫与淘宝上每天产生了大量的交易，每一笔交易会生成一条交易记录。现在有许多交易记录文件，文件中每一行视作一条交易记录，每条记录中可能包含若干Key-Value对，这样的key-value对称为属性。文件内的交易记录之间是无序的。你的任务是将这些小文件组织成有序的形式并提供查询接口，供业务方查询。

1. 提供交易ID，查询某次交易的某些属性，比如查询某次交易的收货地址以及电话。查询的字段可能不在交易记录中，需要到商品信息或者买家信息中查询。
2. 查询某位买家某个时间范围内的所有交易信息，比如查询买家在2016.4.14~2016.4.15之间所有交易的交易ID与交易金额。输出结果按交易时间从大到小排列
3. 查询某位卖家的某个商品的全部交易订单，输出结果按交易订单id从小到大排序
4. 对某个商品的所有交易信息进行求和，比如查询某个卖家商品的折扣券金额总和

### 成绩
比赛的最终排名13。3275s构建时间 9.8w查询

### 比赛环境、数据
正式环境中的数据分为order,buyer和good三种，实际数据量分别在4亿、800w和400w。 比赛的机器配置为3 * 1.5T的硬盘 8核CPU和 4G的JVM内存。

### 查询和索引结构
由于原始的order文件较大，不可能去遍历查询，因此在索引文件中记录每条记录的偏移，并利用hash的思路将索引文件分割为小文件。

1. 查询1:索引的思路就是根据orderid来hash切割order文件，索引文件里面记录了每个orderid对应的order原始文件、偏移offset和记录长度length。 查找的时候根据orderid去hash索引文件中查找对应的索引，并去原始的order文件中查找记录。
2. 查询2、3、4的结构与查询1很类似,。查询2的索引格式为\<buyerid+createtime: 对应的order原始文件、偏移offset和记录长度length\>。最后去order的原始文件中查找原始order的记录。查询3, 4的索引格式为\<goodid：order索引信息\>。
3. Join操作:4种查询可能都会涉及到buyer和good原始数据字段的查询，此时需要根据对应的buyerid或者(goodid)去对应的buyer(或者good)文件中读取对应的字段。这部分信息索引的结构也是buyer(good)原始文件、偏移offset和记录长度length。由于buyer和good的数据量较小，这部分按照buyerid(或者goodid)放到内存中，使用hashmap进行记录。

### 索引构建优化
1. 3个线程同时建立3个order索引(查询3,4的索引一致)，并将索引分别写到3个磁盘上，这样避免多线程访问一个磁盘可能带来的磁头寻道的开销。与此同时，另外2个线程进行buyer、good索引的建立。在实际测试中，先建立3个order索引，在再建立buyer和good的索引与5个线程同时跑，5个线程稍好一些。
2. 文件分割的越多查询速度越快（因此需要遍历的文件内容少），但是相应的构建索引的时间也会越长。
3. 在读取源文件并建立索引的过程中，使用一个缓冲区，读取一定量的数据之后再进行处理，充分利用磁盘的预读。
4. 建立索引时避免使用String.split()进行切割，这样会导致大量的无用切割和复制，具体优化的方法可以参考StringUtils.createKVMapFromLineWithSet()。
5. 由于buyer和good的数目已已知，因此内存map初始化的时候可以直接设置大小，并设置loadFactor为1f，这样可以防止map不断扩容带来的rehash开销。

### 查询优化
1. 查询2、3、4和join都需要读多条原始文件的数据，而这些数据可能有的是在同一个文件中的，而有的记录可能靠得比较近，如果每条记录都单独打开文件并读取的话会带来不必要的开销，并且也可能无法利用系统的IO缓冲区。此处的优化是读取原始文件时，将同一个原始文件的索引信息聚在一起，并按照记录的offset排序，这样能最大程度的减少不必要的IO开销并重复利用系统IO缓冲区。
2. 比赛提供的是8核CPU，所以查询时可以利用多核的优势。由于在读取order原始数据的时候可能涉及到多个文件，因此将一个文件的读取作为一个Callable传递给线程池，此处采用的是fixed的线程池，查询2、3、4各有一个corePoolSize为8的线程池。具体的Callable实现类为CallableOrderDataSearch。虽然Join操作也可以使用线程池，但是线上测试的结果显示join时间占总时间较小，所以没有采用。
3. Join优化1(这里以查询2为例，查询3、4同理):查询一个buyer在一个时间段内的所有订单并join时，需要join的buyer信息是一定的，因此对应的buyer信息只需要查询一次即可。Good信息同理。
4. Join优化2:由于某些字段只会在某些文件中出现(如price字段只会在good原始文件中出现)，因此对于查询3、4，如果查询的key只有在good或者order中出现(good只需要join一次，而order不需要join)，那么就不需要join buyer信息。
5. 查询4的专用优化：首先判断查询4的字段是否可以求和，不能求和直接返回空。然后通过字段判断需要join的表。查询4是根据goodid去查找所有order信息然后join，最后对某一个字段求和。如果这个字段信息只有在good文件中才会出现，那么只需要根据内存map的信息去good原始文件中获得这个字段的值（如果是long或者double类型的话），然后根据查询3的索引统计该good所有订单的数量。相乘返回即可。
